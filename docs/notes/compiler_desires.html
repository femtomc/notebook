<html>
<head>
<title>McCoy R. Becker</title>
<meta name="robots" content="no index, nofollow" charset="utf-8">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<link rel="stylesheet"
      href="../highlight/styles/default.min.css">
<script src="../highlight/highlight.min.js"></script>
<script src="../highlight/languages/haskell.min.js"></script>
<style>
@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
@import url(https://fonts.googleapis.com/css2?family=PT+Serif&display=swap);
</style>
<link rel="stylesheet" type="text/css" href="../assets/css/fonts.css"/>
<link rel="stylesheet" type="text/css" href="../assets/css/style.css"/>
</head>
<body>
<div id="doc"><h1>Feelings about language and compiler implementations</h1><p>This is going to be a bit of a ramble. I feel like I complain about language and compiler design features more than your average programmer. I think it’s perfectly fine to complain about things like this, especially in programming - where there are strong incentives (even tendencies!) to settle into ecosystem-based language optima. I suspect the study and usage of programming languages exemplifies the “perfect is the enemy of the good” ethos. Nonetheless, new ideas which radically simplify things will always be attractive to me - even if the cost in a language implementation is that you have to start with a young ecosystem.</p><p><i>I know what I like</i> in programming languages. I started with Python,  then I used Julia, then I messed around with Rust, then I used C for a bit, which helped me realize that Rust was really nice, then I used Julia a lot, then I played around with Haskell. Along the way, I’ve used Scala, OCaml, Racket, Zig, Coq, even a little bit of VHDL for an FPGA course project. By far, I’m most comfortable with Julia and Rust. Of course, I reach for them for different things - but I’m reasonably confident that I could put together medium to large codebases in each language and not have it be a total disaster.</p><p>I like Julia for many reasons. It feels like the “code is data, data is code” ethos of Lisp has been built into the DNA of the compiler. The official language compiler implementation is also fast, and the community is obsessed with making it faster in the ways that count. The community is also quite smart–I’m learned more than a measurable amount of useful tidbits just by engaging with the community.</p><p>The language implementation is also well-designed, even though it currently requires a GC - the compiler is smart enough to not generate a lot of garbage. The language combination of subtyping and multiple dispatch has created this composability solace (from the framework chaos which dominates modern computing). Julia was sort of like my gateway drug to language/compiler things. On the other hand, there are things about Julia which frustrate me. When you start to get into the Julia compiler, there are packages which lull you into a false sense of promise - the promise that you (yes, you, intrepid programmer) can explore truly insane things like full language AD, or plugging compiler passes into the hot running runtime, even changing inference (which is for performance, not correctness, so it’s all good). In practice, there are limitations built into the compiler (for good reasons! which make sense when you start to read about Julia’s type inference, and the requirements of dynamism). There are pedantic things, like the “unorthodox” (at least, compared to traditional AOT compilers) workflow for compiling Julia code to a binary. Or the fact that Julia’s AD story is sort of ... in a rut (at least, at the time of this writing, early 2022). Most of all, I think I’ve used and enjoyed Julia more than any other language I’ve played around with - and sometimes I’ve just wanted to expand my horizons, explore other ideas, etc. Julia is beautiful, but no matter where you are at, sometimes you might get the “grass is always greener” sort of feeling.</p><p>I like Rust because the compiler toolchain is (I think, bar none) the best thing I’ve ever used. It’s crazy how many QoL things are just part of the toolchain, and just work seamlessly. Using the Rust compiler honestly feels like cheating. There’s this weird quality to the Rust workflow which I can only encapsulate with “solid” or “robust”. It just feels good. Coming from Julia (with Julia’s emphasis on multiple dispatch and subtyping), I appreciate traits - sometimes I’ve reached for idioms which I would use in Julia, and I forget that subtyping is not a thing in Rust (although dynamic dispatch via trait objects is a thing). The error handling is also very well done (especially compared to Go, for example, or other languages which don’t even provide special syntax or facilities for propagating errors).</p><h2>Things I dislike</h2><p>I sort of hate Python - but not really enough to work myself into a passion about it. I just sort of think it’s bland. It’s a bland language, the native interpreter-based implementation is slow, lack of any form of typing hurts my soul and prevents me from rapidly reading Python code (I think this is the big thing for me). “Bind the real framework from C++ in Python” things appear to be like composability poison (especially if you get used to Julia, where everything “just composes” via multiple dispatch and subtyping).</p><p>I hate C++, probably with an intensity which is unwarranted. I just fundamentally do not understand (outside of ecosystem momentum! which is obviously a big thing) why anyone would use C++ today. The tooling feels like complicated garbage (conan seems alright, but then that’s a project-specific thing–and not enforced like Rust “strong opinion” enforces cargo), CMake feels complicated, imposing, just not worth it? Templates are too powerful, and lead to incredibly complicated debugging. Even the very, very small amount of work with templates I’ve done has scared me. Metaprogramming templates–which seems to increasingly be a modern accepted idiom, honestly nauseates me. It’s one of these things where it feels like either I’m going to have to spend 6 months to a year to learn it deeply, or I’m just not going to get it. That’s a waste of time in my opinion–just to learn the tool! It’s not even the things I want to express, it’s just the stupid tool I need to use to express them.</p><p>In my biased head, Rust is basically superior to C++ in every single way <i>except for ecosystem</i>, which is one of the most important reasons for why anyone uses any language. I feel sort of comfortable with Rust, I would consider myself an intermediate Rust programmer. I’ve spent many weeks looking at C++ code, trying to get certain compiler things working (LLVM/MLIR) with the CMake tooling - I’ve just found it be hard, in a cognitively draining way.</p></div>
</script>
</body>
<script>hljs.highlightAll();</script>
</html>