<html>
<head>
<title>McCoy R. Becker</title>
<meta name="robots" content="no index, nofollow" charset="utf-8">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="../assets/js/mathjax3-tex-svg.js">
</script>
<link rel="stylesheet"
      href="../assets/js/highlight/styles/default.min.css">
<script src="../assets/js/highlight/highlight.min.js"></script>
<script src="../assets/js/highlight/languages/haskell.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');
</style>
<link rel="stylesheet" type="text/css" href="../assets/css/fonts.css"/>
<link rel="stylesheet" type="text/css" href="../assets/css/style.css"/>
</head>
<body>
<div id="doc"><h1>AIDE: towards automatic inference tuning</h1><p><a href="https://arxiv.org/pdf/1705.07224.pdf">AIDE</a> is a technique for measuring the accuracy of probabilistic inference algorithms by computing an estimator for the symmetric Kullback-Leibler (KL) divergence between the approximating distributions of two inference algorithms.</p><p>In this note, I’ll be working through the paper - attempting to provide informal context where necessary.</p><h2>Background</h2><p>First, some background. In approximate Bayesian inference, the goal is to compute an approximation of the posterior that converges to the true posterior in some limit of computation. In Monte Carlo (importance) sampling, for example, the limit may be the number of samples. In Markov chain Monte Carlo (MCMC), this limit is the number of transition steps.</p><p>Often times, these limits are framed by considering an expectation taken with respect to the target distribution, e.g.</p><p><mathjax>\begin{equation}E[X;P] \approx \hat{E}_n[X;P] = \frac{1}{n}\sum_{i=1}^n x_i\end{equation}</mathjax></p><p>These algorithms are configurable.</p><p>In importance sampling, the user can provide a proposal distribution which the algorithm will sample from (but the proposal must cover the support of the posterior). Intuitively, the closer the proposal is to the true posterior, the smaller the number of samples required to reduce the variance to a specified tolerance. So the choice of proposal distribution has ramifications for the amount of computation required to estimate the expectation. The theoretical “best” proposal distribution requires only a single sample - in practice, usage almost always necessitates taking a number of samples and computating the expectation using a weighted average. A good reference here on proposals, variance bounds, and computation is <a href="https://projecteuclid.org/journals/annals-of-applied-probability/volume-28/issue-2/The-sample-size-required-in-importance-sampling/10.1214/17-AAP1326.full">Chatterjee and Diaconis, 2018</a>.</p><p>A similar characterization is true for MCMC, where the user can provide a kernel (which must satisfy a property called detailed balance with respect to the target distribution to ensure that the Markov chain targets the correct distribution). The computational limit parameter in question is the length of the Markov chain.</p><p>Often times, categorization of these algorithms discuss these explicit parameters in great detail - but in practice, there are also implicit computational costs which must be considered when designing custom inference algorithms. In importance sampling, sampling from the proposal distribution and evaluation of log-likelihood functions are two computational processes which are effectively involved in every sampling step. In MCMC, sampling from the kernel and evaluation of the accept-reject ratio are involved in every step.</p><p>These implicit costs must be considered in the practical design of inference - e.g. an algorithm which theoretically converges quickly may practically be unacceptable under computational restrictions. In many practical cases of Bayesian inference, effective algorithms which are known to be empirically successful from the literature will be run for a restricted number of steps. In MCMC, for example, this induces accuracy penalties against the true posterior. So the goal, really, is not choosing an algorithm by comparing behavior in the theoretical <mathjax>$n \rightarrow \infty$</mathjax> limit, but comparing algorithms within a fixed computational restriction.</p><p>AIDE is a technique which seeks to address part of this design problem.</p><figure><p><img src="assets/aide.png"/></p><figcaption>The AIDE architecture, as presented in <a href="https://arxiv.org/pdf/1705.07224.pdf">Cusumano-Towner and Mansinghka, 2017</a>.</figcaption></figure><h2>Inference and meta-inference</h2><p>One important thing to understand is that AIDE sits within a conceptual framework for probabilistic and inference programming developed by (<a href="https://www.mct.dev/">Marco Cusumano-Towner</a> <a href="http://probcomp.csail.mit.edu/">et al</a>) called <a href="https://www.gen.dev/">Gen</a>. The paper is full of terminology which overlaps with this project - including things like traces and generative functions.</p><p>In particular, the way that AIDE is applied to inference algorithms is by framing them as <i>generative inference models</i> - <a href="https://www.mct.dev/assets/mct-thesis.pdf">generative models</a> (whose mathematical background is covered in great depth in Marco’s thesis) which return the output density of the inference algorithm when marginalized over internal random choices. This choice essentially motivates what follows - the difficulty of computing densities of inference algorithms occurs because it is difficult to marginalize over internal random choices of the algorithm. The authors specify: let’s treat inference algorithms as generative models, and then use techniques from marginal likelihood estimation in a Monte Carlo estimator of divergence between output distributions of the two algorithms.</p><hr/><h4>Generative inference model</h4><p>A tuple <mathjax>$(U, X, q)$</mathjax> where <mathjax>$q(u, x)$</mathjax> is a joint density on <mathjax>$U \times X$</mathjax>. A generative inference model <i>models</i> an inference algorithm if the output density of the inference algorithm is the marginal <mathjax>$q(x) = \int q(u, x) \ du$</mathjax>. An element <mathjax>$u \in U$</mathjax> represents a complete assignment to the internal random choices within the inference algorithm (and, following Gen terminology, is called a trace). The interface to generative inference models require that it is possible to simulate (sample) from <mathjax>$q(u, x)$</mathjax> but analytic computation of the density is not required.</p><h4>Meta-inference algorithm</h4><p>For a given <i>generative inference model</i> <mathjax>$(U, X, q)$</mathjax>, a meta-inference algorithm is a tuple <mathjax>$(r, \xi)$</mathjax> where <mathjax>$r(u; x)$</mathjax> is a density on traces <mathjax>$u \in U$</mathjax> indexed (possibly implicitly conditioned on, or represented as a function which accepts) on <mathjax>$x$</mathjax>. <mathjax>$\xi(u, x)$</mathjax> is defined as</p><p><mathjax>\begin{equation}\xi(u, x) = Z \frac{q(u, x)}{r(u; x)}, \text{for some $Z &gt; 0$}\end{equation}</mathjax></p><p>The interface to meta-inference algorithms requires the ability to sample <mathjax>$u ~ r(u; x)$</mathjax> and evaluate <mathjax>$\xi(u, x)$</mathjax> for specified <mathjax>$u$</mathjax> and <mathjax>$x$</mathjax>.</p><p>(<a href="https://arxiv.org/pdf/1705.07224.pdf">c.f. section 3.1 of the paper</a>) Conceptually, a meta-inference sampler tries to answer the question “how could my inference algorithm have produced this output <mathjax>$x$</mathjax>?”</p><p>Note that if it is tractable to evaluate the marginal likelihood <mathjax>$q(x)$</mathjax> of the generative inference model up to a normalizing constant, then it is not necessary to represent internal random variables for the inference algorithm, and a generative inference model can define the trace as an empty token <mathjax>$u = ()$</mathjax> with <mathjax>$U = \{()\}$</mathjax>. In this case, the meta-inference algorithm has <mathjax>$r(u; x) = 1, \forall x$</mathjax> and <mathjax>$ξ(u, x) = Zq(x)$</mathjax>.</p><hr/><p>So, what exactly does a generative inference model and meta-inference algorithm look like?</p><p>The authors present a meta-inference algorithm for SMC (which I discuss a bit more in <span class="xlink"><xlink>notes/unreasonable_smc.html</xlink><a class="xlink" href="../notes/unreasonable_smc.html">The unreasonable effectiveness of rejuvenation move SMC</a></span> and <span class="xlink"><xlink>notes/smc_samplers.html</xlink><a class="xlink" href="../notes/smc_samplers.html">Notes on sequential Monte Carlo</a></span>).</p><figure><p><img src="assets/aide_smc.png"/></p><figcaption>Meta-inference sampler for SMC, as presented in <a href="https://arxiv.org/pdf/1705.07224.pdf">Cusumano-Towner and Mansinghka, 2017</a>.</figcaption></figure><h2>The estimator</h2><p>A key part of AIDE is the usage of the symmetrized KL divergence as a measure of difference between distributions. The KL divergence is defined as</p><p><mathjax>\begin{equation}D_{KL}(P, Q) = \sum_{x\in X}P(x) \log \big( \frac{P(x)}{Q(x)} \big)\end{equation}</mathjax></p><p>which is not a metric, although it satisfies some properties of metrics, like <mathjax>$D_{KL}(P, Q) \geq 0$</mathjax> with saturation if <mathjax>$P \equiv Q$</mathjax> almost everywhere. The symmetrized KL divergence looks like the following</p><p><mathjax>\begin{equation}D_{KL}(P, Q) = \sum_{x\in X}(P(x) - Q(x)) \log \big( \frac{P(x)}{Q(x)} \big)\end{equation}</mathjax></p><figure><p><img src="assets/aide_alg.png"/></p><figcaption>The AIDE algorithm, as presented in <a href="https://arxiv.org/pdf/1705.07224.pdf">Cusumano-Towner and Mansinghka, 2017</a>.</figcaption></figure></div>
</script>
</body>
<script>hljs.highlightAll();</script>
</html>